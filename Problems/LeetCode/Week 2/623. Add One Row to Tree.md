## ðŸ“ Problem Details

- **Title:** `623. Add One Row to Tree`
- **Link:** https://leetcode.com/problems/add-one-row-to-tree/
- **Difficulty:** #Medium 
- **Tags/Categories:** #BFS #DFS #Trees 

## ðŸ’­What Were My Initial Thoughts?

```
- DFS to find the element 1-above our depth
- BFS to move across the level
	- if curr has a left child
		- create a TreeNode as curs left child, make its left child the previous left child
	- if curr has a right child
		- create a TReeNode as curs right child, make its right child the previous right child
```

## ðŸ¤”What Did I Struggle With?

```
- solution was correct, took me a little while to come to it 
- was uncertain of combining traversal methods
- using just BFS was enough 
```

## ðŸ’¡ Explanation of Solution

```
- use a queue to perform level-order traversal (BFS)
- continue traversal until we reach depth-1
```

## âŒ› Complexity Analysis

```
- Worst case of O(n)
```

## ðŸ’» Implementation of Solution

```cpp
class Solution {

public:

Â  Â  TreeNode* addOneRow(TreeNode* root, int val, int depth) {

Â  Â  Â  Â  if(root == nullptr) return nullptr;
Â  Â  Â  Â  
Â  Â  Â  Â  if(depth == 1) {
Â  Â  Â  Â  Â  Â  TreeNode* newRoot = new TreeNode(val);
Â  Â  Â  Â  Â  Â  newRoot->left = root;
Â  Â  Â  Â  Â  Â  return newRoot;
Â  Â  Â  Â  }

Â  Â  Â  Â  queue<TreeNode*> q;
Â  Â  Â  Â  q.push(root);
Â  Â  Â  Â  int currentDepth = 1;

Â  Â  Â  Â  while(!q.empty()) {
Â  Â  Â  Â  Â  Â  int levelSize = q.size();
Â  Â  Â  Â  Â  Â  if(currentDepth == depth - 1) {
Â  Â  Â  Â  Â  Â  Â  Â  //modify the nodes at the current depth
Â  Â  Â  Â  Â  Â  Â  Â  for(int i=0; i < levelSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  TreeNode* node = q.front();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  q.pop();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  TreeNode* oldLeft = node->left;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  TreeNode* oldRight = node->right;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  node->left = new TreeNode(val);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  node->right = new TreeNode(val);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  node->left->left = oldLeft;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  node->right->right = oldRight;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // Continue BFS
Â  Â  Â  Â  Â  Â  for (int i = 0; i < levelSize; ++i) {
Â  Â  Â  Â  Â  Â  Â  Â  TreeNode* node = q.front();
Â  Â  Â  Â  Â  Â  Â  Â  q.pop();
Â  Â  Â  Â  Â  Â  Â  Â  if (node->left) q.push(node->left);
Â  Â  Â  Â  Â  Â  Â  Â  if (node->right) q.push(node->right);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ++currentDepth;
Â  Â  Â  Â  }
Â  Â  Â  Â  return root;
Â  Â  }
};
```