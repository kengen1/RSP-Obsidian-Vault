## üìù Problem Details

- **Title:** `1220. Count Vowels Permutation`
- **Link:** https://leetcode.com/problems/count-vowels-permutation/
- **Difficulty:** #Hard 
- **Tags/Categories:** #Dynamic-Programming 

## üí≠What Were My Initial Thoughts?

```
- the number of possible permutations grows exponentially with the length of the sequence n
- brute force would be to generate all possible vowel sequences of length n and check each sequence to see if it satisfies the given rules for valid transitions between vowels
- many sequences share the same suffix or prefix sequence 
- dynamic programming seems like the appropriate approach since we can store and reuse calculations for overlapping subproblems (sequences)
```

## ü§îWhat Did I Struggle With?

```
- implementing the storage of overlapping subproblems
- accurately defining the subproblem
```

## üí° Explanation of Solution

```
- create a matrix `dp` where dp[i][v] represent the number of valid strings of length i that end with the vowel v

1. Define the transitions based on the rules
	- dp[i+1][a] = dp[i][e] + dp[i][u] + dp[i][i]
	- dp[i+1][e] = dp[i][a] + dp[i][i]
	- dp[i+1][i] = dp[i][e] + dp[i][o]
	- dp[i+1][o] = dp[i][i]
	- dp[i+1][u] = dp[i][o] + dp[i][i]

2. Base case: at i=1, dp[1][v] for each vowel v, as a single character string can be any vowel

3. Iterate for n: Compute dp[i][v] for all vowels at each string length i up to n

4. Sum the results: The answer is the sum of dp[n][a],   dp[n][e],   dp[n][i],   dp[n][o],   dp[n][u]

5. Optimization:
```

## ‚åõ Complexity Analysis

```

```

## üíª Implementation of Solution

```cpp

```