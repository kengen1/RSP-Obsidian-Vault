## 📝 Problem Details

- **Title:** `65. Unique Paths II`
- **Link:** https://leetcode.com/problems/unique-paths-ii/
- **Difficulty:** #Medium 
- **Tags/Categories:** #Arrays #Matrix #Dynamic-Programming 

## 💭What Were My Initial Thoughts?

```
- recursively check the right and bottom moves
	- if they are in bounds
	- or not being blocked by an obstacle
- helper function to count the number of paths that make it to the finish point
```

## 🤔What Did I Struggle With?

```
- only returning unique paths
- memorising already traversed paths to reduce time complexity
```

## 💡 Explanation of Solution

```

```

## ⌛ Complexity Analysis

```
Time Complexity:
- recursive calls : each cell 
```

## 💻 Implementation of Solution

```cpp
class Solution {

public:

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int rows = obstacleGrid.size(), cols = obstacleGrid[0].size();
        vector<vector<int>> memo(rows,vector<int>(cols, -1));
        return countPaths(obstacleGrid, 0, 0, memo);
    }

    int countPaths(vector<vector<int>>& grid, int row, int col, vector<vector<int>>& memo) {
        if(row >= grid.size()
        || col >= grid[0].size()
        || grid[row][col] == 1)
            return 0;

  

        // if at the destination, return 1
        if(row == grid.size()-1 && col == grid[0].size()-1)
            return 1;
  
        // if already computed, return stored value
        if(memo[row][col] != -1) {
            return memo[row][col];
        }

        // recursively call for right and down moves
        memo[row][col] = countPaths(grid, row, col+1, memo) + countPaths(grid, row+1, col, memo);
        return memo[row][col];
    }
};
```