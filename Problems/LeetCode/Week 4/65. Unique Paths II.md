## ğŸ“ Problem Details

- **Title:** `65. Unique Paths II`
- **Link:** https://leetcode.com/problems/unique-paths-ii/
- **Difficulty:** #Medium 
- **Tags/Categories:** #Arrays #Matrix #Dynamic-Programming 

## ğŸ’­What Were My Initial Thoughts?

```
- recursively check the right and bottom moves
	- if they are in bounds
	- or not being blocked by an obstacle
- helper function to count the number of paths that make it to the finish point
```

## ğŸ¤”What Did I Struggle With?

```
- only returning unique paths
- memorising already traversed paths to reduce time complexity
```

## ğŸ’¡ Explanation of Solution

```

```

## âŒ› Complexity Analysis

```
Time Complexity:
- recursive calls : each cell 
```

## ğŸ’» Implementation of Solution

```cpp
class Solution {

public:

Â  Â  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
Â  Â  Â  Â  int rows = obstacleGrid.size(), cols = obstacleGrid[0].size();
Â  Â  Â  Â  vector<vector<int>> memo(rows,vector<int>(cols, -1));
Â  Â  Â  Â  return countPaths(obstacleGrid, 0, 0, memo);
Â  Â  }

Â  Â  int countPaths(vector<vector<int>>& grid, int row, int col, vector<vector<int>>& memo) {
Â  Â  Â  Â  if(row >= grid.size()
Â  Â  Â  Â  || col >= grid[0].size()
Â  Â  Â  Â  || grid[row][col] == 1)
Â  Â  Â  Â  Â  Â  return 0;

  

Â  Â  Â  Â  // if at the destination, return 1
Â  Â  Â  Â  if(row == grid.size()-1 && col == grid[0].size()-1)
Â  Â  Â  Â  Â  Â  return 1;
  
Â  Â  Â  Â  // if already computed, return stored value
Â  Â  Â  Â  if(memo[row][col] != -1) {
Â  Â  Â  Â  Â  Â  return memo[row][col];
Â  Â  Â  Â  }

Â  Â  Â  Â  // recursively call for right and down moves
Â  Â  Â  Â  memo[row][col] = countPaths(grid, row, col+1, memo) + countPaths(grid, row+1, col, memo);
Â  Â  Â  Â  return memo[row][col];
Â  Â  }
};
```