## üìù Problem Details

- **Title:** `309. Best Time to Buy and Sell Stock with Cooldown`
- **Link:** https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
- **Difficulty:**  #Medium 
- **Tags/Categories:**  #Dynamic-Programming #Arrays 

## üß™Problem Description

```

```

## üî≠Key Observations

```

```

## üí° Explanation of Solution

```

```

## ‚åõ Complexity Analysis

```

```

## üíª Implementation of Solution

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // State: buying or selling?
        // Buying --> i+1
        // Selling --> i+2 (mandatory cooldown day)

        // Hash function for pair<int, bool>
        auto pair_hash = [](const pair<int, bool>& p) -> size_t {
            return hash<int>()(p.first) ^ (hash<bool>()(p.second) << 1);
        };

        // Memoization table with custom hash function
        unordered_map<pair<int, bool>, int, decltype(pair_hash)> dp(0, pair_hash);

        // Recursive function to compute max profit
        function<int(int, bool)> dfs = [&](int i, bool buying) -> int {
            // Base case: if index is out of bounds
            if (i >= prices.size()) return 0;

            // Check if state is already computed
            if (dp.find({i, buying}) != dp.end()) return dp[{i, buying}];

            // Compute result based on current state
            if (buying) {
                int buy = dfs(i + 1, false) - prices[i]; // Buy stock
                int cooldown = dfs(i + 1, true);        // Skip (cooldown)
                dp[{i, buying}] = max(buy, cooldown);
            } else {
                int sell = dfs(i + 2, true) + prices[i]; // Sell stock
                int cooldown = dfs(i + 1, false);       // Skip (cooldown)
                dp[{i, buying}] = max(sell, cooldown);
            }

            return dp[{i, buying}];
        };

        // Start recursion from day 0 in the buying state
        return dfs(0, true);
    }
};
```