## ğŸ“ Problem Details

- **Title:** `778. Swim in Rising Water`
- **Link:** https://leetcode.com/problems/swim-in-rising-water/
- **Difficulty:** #Hard 
- **Tags/Categories:** #Matrix #Graphs #Dijkstras-Shortest-Path #Union-Find #Path-Finding 

## ğŸ§ªProblem Description

```
You are given an n x n grid of integers
Each cell in the grid represents the elevation of the land at that cell
The objective is to determine the minimum time T such that you can swim from the top-left cell (0,0) to the bottom right cell (n-1, n-1), assuming:
	1. At time T, you can swim in any cell whose elevation <= T
	2. You can move up, down, left or right from one cell to another

```

## ğŸ”­Key Observations

```
1. Elevation as a Constraint:
- you can only move into a cell if T >= elevation[cell]
- at time T, all cells with elevation <= T are "accessible"

2. Goal:
- minimize T, so you reach (n-1, n-1) with the smallest possible elevation threshold

3. Pathfinding:
- you are essentially trying to find a path from (0,0) to (n-1, n-1) where the maximum elevation you encounter on the path is minimized

```

---

# ğŸ’¡ *Approach 1* : Dijkstra's Algorithm

```
treat the problem as a graph traversal problem, where each cell is a node, and the elevation acts as the "cost" to enter the cell

- use a priority queue (min-heap) to explore the grid
- at each step, process the cell with the lowest elevation first
- track the maximum elevation encountered so far to reach each cell
```

## âŒ› Complexity Analysis

```
Time Complexity: 
O(n^2 log n), since each of the n^2 cells is processed and pushed into the priority queue
^ this is an improvement over the brute force approach which warrants an exponential time complexity O(2^n)

Space Compleixty:
O(n^2) for the auxilary space of the priority queue and the visited array

```

## ğŸ’» Implementation of Solution

```cpp
class Solution {

private:
Â  Â  const vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
Â  Â  
public:
Â  Â  int swimInWater(vector<vector<int>>& grid) {
Â  Â 
Â  Â  Â  Â  int n = grid.size();

Â  Â  Â  Â  // priority queue: {max elevation on path, row, col}
Â  Â  Â  Â  priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<>> pq;

Â  Â  Â  Â  // visited array to avoid revisiting cells
Â  Â  Â  Â  vector<vector<bool>> visited(n, vector<bool>(n, false));

Â  Â  Â  Â  // push the starting cell (0,0) into the priority queue
Â  Â  Â  Â  pq.emplace(grid[0][0], 0,0);
Â  Â  Â  Â  visited[0][0] = true;

Â  Â  Â  Â  // explore the grid
Â  Â  Â  Â  while(!pq.empty()) {
Â  Â  Â  Â  Â  Â  auto [current_max, row, col] = pq.top();
Â  Â  Â  Â  Â  Â  pq.pop();
  
Â  Â  Â  Â  Â  Â  // if we reach the bottom-right corner, return the current max elevation
Â  Â  Â  Â  Â  Â  if(row == n-1 && col == n-1)
Â  Â  Â  Â  Â  Â  Â  Â  return current_max;

Â  Â  Â  Â  Â  Â  // explore all 4 possible directions
Â  Â  Â  Â  Â  Â  for(const auto& [dx, dy] : directions) {
Â  Â  Â  Â  Â  Â  Â  Â  int newRow = row + dx;
Â  Â  Â  Â  Â  Â  Â  Â  int newCol = col + dy;
  
Â  Â  Â  Â  Â  Â  Â  Â  // check bounds and if the cell is already visited
Â  Â  Â  Â  Â  Â  Â  Â  if(newRow >= 0 && newRow < n
Â  Â  Â  Â  Â  Â  Â  Â  && newCol >= 0 && newCol < n
Â  Â  Â  Â  Â  Â  Â  Â  && !visited[newRow][newCol]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  visited[newRow][newCol] = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // add the new cell to the queue qith the updated max elevation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pq.emplace(max(current_max, grid[newRow][newCol]), newRow, newCol);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return -1;
Â  Â  }
};
```



--- 


# ğŸ’¡ *Approach 2* : Disjoint Set (Union-Find)

```
treat the grid as a set of connected components, where the idea is to progressively "flood" the grid by increasing T, connecting accessible cells into a single component

- sort all the cells by their elevation
- gradually process the cells in increasing order of elevation, connecting them to their neighbours using a union-find data structure
- stop when (0,0) and (n-1, n-1) belong to the same connected component

```

## âŒ› Complexity Analysis

```
TC: O(n^2 Î± (n^2)), where Î± is the inverse ackermann function (nearly constant in practice)
```

## ğŸ’» Implementation of Solution

```cpp
class DSU {
Â  Â  vector<int> parent;
Â  Â  vector<int> rank;

public:

Â  Â  DSU(int n) {
Â  Â  Â  Â  parent.resize(n);
Â  Â  Â  Â  rank.resize(n,0);
Â  Â  Â  Â  for(int i=0; i < n; i++) {
Â  Â  Â  Â  Â  Â  parent[i] = i;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // find operation with path compression
Â  Â  int find(int x) {
Â  Â  Â  Â  if(parent[x] != x) {
Â  Â  Â  Â  Â  Â  parent[x] = find(parent[x]);
Â  Â  Â  Â  }
Â  Â  Â  Â  return parent[x];
Â  Â  }

  
Â  Â  void unite(int x, int y) {
Â  Â  Â  Â  int rootX = find(x);
Â  Â  Â  Â  int rootY = find(y);

Â  Â  Â  Â  if(rootX != rootY) {
Â  Â  Â  Â  Â  Â  if (rank[rootX] > rank[rootY]) {
Â  Â  Â  Â  Â  Â  Â  Â  parent[rootY] = rootX;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  else if (rank[rootX] < rank[rootY]) {
Â  Â  Â  Â  Â  Â  Â  Â  parent[rootX] = rootY;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â  Â  parent[rootY] = rootX;
Â  Â  Â  Â  Â  Â  Â  Â  rank[rootX]++;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
};

  
class Solution {

public:
Â  Â  // function to convert 2D grid coordinates to 1D index
Â  Â  int toIndex(int row, int col, int n) {
Â  Â  Â  Â  return row * n + col;
Â  Â  }

Â  Â  int swimInWater(vector<vector<int>>& grid) {
Â  Â  Â  Â  int n = grid.size();
Â  Â  Â  Â  
Â  Â  Â  Â  // step 1: flatten the grid into a list of {elevation, row, col}
Â  Â  Â  Â  vector<tuple<int,int,int>> cells;

Â  Â  Â  Â  for(int row = 0; row < n; row++) {
Â  Â  Â  Â  Â  Â  for(int col = 0; col < n; col++) {
Â  Â  Â  Â  Â  Â  Â  Â  cells.emplace_back(grid[row][col], row, col);
Â  Â  Â  Â  Â  Â  } Â  Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  // step 2: sort the cells by elevation
Â  Â  Â  Â  sort(cells.begin(), cells.end());
  
Â  Â  Â  Â  // step 3. initialise the DSU for all grid cells
Â  Â  Â  Â  DSU dsu(n * n);
  
Â  Â  Â  Â  // directions for movement: up, down, left, right
Â  Â  Â  Â  const vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; Â  Â 

Â  Â  Â  Â  // step 4. process cells in increasing order of elevation

Â  Â  Â  Â  for(const auto& [elevation, row, col] : cells) {
Â  Â  Â  Â  Â  Â  for(const auto& [dx, dy] : directions) {
Â  Â  Â  Â  Â  Â  Â  Â  int newRow = row + dx;
Â  Â  Â  Â  Â  Â  Â  Â  int newCol = col + dy;

Â  Â  Â  Â  Â  Â  Â  Â  // check bounds
Â  Â  Â  Â  Â  Â  Â  Â  if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If the neighbor has been processed, unite the current cell with the neighbor
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (grid[newRow][newCol] <= elevation) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dsu.unite(toIndex(row, col, n), toIndex(newRow, newCol, n));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // step 5. check if the top-left and bottom-right are connected
Â  Â  Â  Â  Â  Â  if(dsu.find(0) == dsu.find(toIndex(n-1, n-1, n))) {
Â  Â  Â  Â  Â  Â  Â  Â  return elevation;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return -1;
Â  Â  }
};
```
