## üìù Problem Details

- **Title:** `1981. Minimize the Difference Between Target and Chosen Elements`
- **Link:** https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/
- **Difficulty:** #Medium 
- **Tags/Categories:** #Dynamic-Programming #Arrays 

## üî≠ Key Observations

```
1. The problem requires finding a set of elements, one from each row of the matrix, that minimizes the absolute difference between their sum and the target.

2. Key Insights:
   - Since each row can have multiple elements, the number of possible combinations is exponential. However, pruning can significantly reduce the computation.
   - Instead of enumerating all combinations, use a dynamic programming (DP) approach to track possible sums after processing each row.
   - Using a `set` allows us to avoid duplicate sums efficiently, reducing unnecessary computations.

3. Key Techniques:
   - Use an unordered set to store all possible sums after processing each row.
   - After processing all rows, compute the minimum absolute difference between the target and all possible sums.
   - Early termination is possible if a sum exactly equals the target (`min_diff == 0`).

```

## üí° Explanation of Solution

```
1. **Initialization**:
    
    - Use a set `current_sums` to store possible sums. Start with `{0}` since initially, there‚Äôs no sum.
2. **Dynamic Programming**:
    
    - For each row in the matrix:
        - Create a new set `next_sums` to store sums generated by adding each element of the row to the sums in `current_sums`.
        - Update `current_sums` with `next_sums` after processing the row.
3. **Prune Unnecessary Computations**:
    
    - Using a set eliminates duplicate sums, reducing the number of combinations processed.
4. **Compute the Result**:
    
    - After processing all rows, iterate through the possible sums stored in `current_sums`.
    - Compute the absolute difference between each sum and the target, and track the minimum difference.
    - If a sum exactly matches the target (`min_diff == 0`), return early.
5. **Return the Result**:
    
    - After processing all possible sums, return the minimum absolute difference.

### Steps

1. Start with an initial sum of `0`.
2. Process each row in the matrix:
    - For each sum in `current_sums`, add each element of the row to the sum and store the result in `next_sums`.
3. After processing all rows, calculate the absolute difference between each possible sum and the target.
4. Return the minimum difference.
```

## ‚åõ Complexity Analysis

```
1. **Time Complexity**:
   - For each row, we compute the cartesian product of `current_sums` and the row elements.
   - Let `k` be the size of `current_sums` after processing each row and `n` be the number of columns in a row:
     - Each row contributes `O(k * n)` updates.
   - In the worst case, `k` can grow exponentially if no pruning is applied.
   - Overall complexity: `O(m * k * n)`, where `m` is the number of rows.

2. **Space Complexity**:
   - Space is used for the `current_sums` set, which can grow exponentially in size.
   - Space complexity: `O(k)` in the worst case.

```

## üíª Implementation of Solution

```cpp
class Solution {
public:
    int minimizeTheDifference(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();

        // Use a set to track possible sums
        unordered_set<int> current_sums = {0};

        // Process each row of the matrix
        for (int row = 0; row < m; ++row) {
            unordered_set<int> next_sums;
            for (int sum : current_sums) {
                for (int element : matrix[row]) {
                    // Update the possible sums
                    next_sums.insert(sum + element);
                }
            }
            current_sums = next_sums;
        }

        // Find the closest sum to the target
        int min_diff = INT_MAX;
        for (int sum : current_sums) {
            min_diff = min(min_diff, abs(sum - target));
            if (min_diff == 0) return 0; // Early termination
        }

        return min_diff;
    }
};

```