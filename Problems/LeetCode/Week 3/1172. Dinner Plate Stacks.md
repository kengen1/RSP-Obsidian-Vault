## ğŸ“ Problem Details

- **Title:** `1172. Dinner Plate Stacks`
- **Link:** https://leetcode.com/problems/24-game/
- **Difficulty:** #Hard 
- **Tags/Categories:**  #Hashmap #Stack #Design 

## ğŸ’­What Were My Initial Thoughts?

```
- private class members for:
	- capacity
	- vector of stacks to allow for infinite addition of stacks
	- need a way of tracking available positions in the event of popAtStack
```

## ğŸ¤”What Did I Struggle With?

```
- coming up with the idea to use a set to track available positions 
```

## ğŸ’¡ Explanation of Solution

```
capacity tracking:
	- store the capacity as a private class member so all methods can access it 

vector of stacks:
	- use a vector<stack<int>> to allow for dynamically expanding stacks 

track available stacks:
	- to optimize the push function, track the first available stack that can take a new value 
	- this can be achieved using a set<int> of indicies for non-full stacks
	- this ensures push remains efficient 

track active stacks:
	- for the pop function, track non-empty stacks 
```

## âŒ› Complexity Analysis

```
O(log N) for push
O(log N) for popAtStack 
```

## ğŸ’» Implementation of Solution

```cpp
class DinnerPlates {

private:
Â  Â  int capacity;
Â  Â  vector<stack<int>> stacks;
Â  Â  set<int> available; // indicies of stacks that can accept more plates

public:
Â  Â  DinnerPlates(int capacity) : capacity(capacity) {}

Â  Â  void push(int val) {

Â  Â  Â  Â  while (!available.empty() && (*available.begin() >= stacks.size() || stacks[*available.begin()].size() == capacity)) {
Â  Â  Â  Â  Â  Â  available.erase(available.begin()); // Remove invalid or full indices
Â  Â  Â  Â  }

Â  Â  Â  Â  if (available.empty()) {
Â  Â  Â  Â  Â  Â  stacks.push_back(stack<int>());
Â  Â  Â  Â  Â  Â  available.insert(stacks.size() - 1);
Â  Â  Â  Â  }

Â  Â  Â  Â  int index = *available.begin();
Â  Â  Â  Â  // Validate index
Â  Â  Â  Â  if (index < 0 || index >= stacks.size()) {
Â  Â  Â  Â  Â  Â  throw runtime_error("Invalid index detected in available set.");
Â  Â  Â  Â  }

Â  Â  Â  Â  stacks[index].push(val);
Â  Â  Â  Â  
Â  Â  Â  Â  if (stacks[index].size() == capacity) {
Â  Â  Â  Â  Â  Â  available.erase(index);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  int pop() {
Â  Â  Â  Â  while(!stacks.empty() && stacks.back().empty()) {
Â  Â  Â  Â  Â  Â  stacks.pop_back();
Â  Â  Â  Â  }

Â  Â  Â  Â  if (stacks.empty()) return -1; // all stacks are empty

Â  Â  Â  Â  int val = stacks.back().top();

Â  Â  Â  Â  stacks.back().pop();

Â  Â  Â  Â  if (stacks.back().size() < capacity) {
Â  Â  Â  Â  Â  Â  available.insert(stacks.size() - 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  return val;
Â  Â  }

Â  Â  int popAtStack(int index) {
Â  Â  Â  Â  if (index < 0 || index >= stacks.size() || stacks[index].empty()) {
Â  Â  Â  Â  Â  Â  return -1;
Â  Â  Â  Â  }
Â  Â  Â  Â  int val = stacks[index].top();
Â  Â  Â  Â  stacks[index].pop();

Â  Â  Â  Â  if (stacks[index].size() < capacity) {
Â  Â  Â  Â  Â  Â  available.insert(index);
Â  Â  Â  Â  }
Â  Â  Â  Â  return val;
Â  Â  }
};

/**
Â * Your DinnerPlates object will be instantiated and called as such:
Â * DinnerPlates* obj = new DinnerPlates(capacity);
Â * obj->push(val);
Â * int param_2 = obj->pop();
Â * int param_3 = obj->popAtStack(index);
Â */
```