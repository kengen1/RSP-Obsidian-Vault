## 📝 Problem Details

- **Title:** `1124. Longest Well-Performing Interval`
- **Link:** https://leetcode.com/problems/longest-well-performing-interval/
- **Difficulty:** #Medium 
- **Tags/Categories:** #Hashmap #Arrays #Prefix-Sum

## 💭What Were My Initial Thoughts?

```
- mind initially went to a sliding window approach but i dont think that would work well
- we need a way of indicating a day as "tiring" as we iterate through the array
	- we can flag and store tiring / not-tiring days in a separate data structure
```

## 🤔What Did I Struggle With?

```

```

## 💡 Explanation of Solution

```
1. input transformation
	- convert the input array hours into a sequence of +1 and -1 based on whether hours[i] > 8 or not 

2. use prefix sum
	- maintain a running sum to track the cumulative effective of transformed values

3. check well-performing conditions
	- if sum > 0, the interval [0....i] is already well-performing because the cumulative effect is positive
	- if the sum <= 0, check if sum - 1 exists in the earlier hashmap
		- if found, calculate the length of the subarray that starts after this index and ends at i

4. record earlier occurrences
	- for each prefix sum, if it hasn't been recorded in earlier, record the current index as the earliest occurence of this sum

5. output the result
	- the value of res keeps track of the longest well performing interval 
```

## ⌛ Complexity Analysis

```

```

## 💻 Implementation of Solution

```cpp

```