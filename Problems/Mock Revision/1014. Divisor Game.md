## üìù Problem Details

- **Title:** `1014. Divisor Game`
- **Link:** https://leetcode.com/problems/divisor-game/
- **Difficulty:** #Easy 
- **Tags/Categories:** #Math #Dynamic-Programming 

## üí≠What Were My Initial Thoughts?

```
rules:
- alice and bob take turns picking a divisor x of n (where x is between 1 and n non-inclusive)
- the number n is updated to n - x
- if a player can't make a move, they lose
- alice always goes first

OBSERVATION: alice can always win if n is even, and will always lose if n is odd
	- if n is even, Alice can always win by making n odd for Bob's turn 
	- if n is odd, Bob can always win by making n even for Alice's turn

	Proof:
	1. if n=1 
		- alice cannot make a move because htere are no divisors x where 1 <= x <= n
		- alice loses , n=1 is a losing state

	2. if n=2
		- alice acn be x=1 (since 2%1 = 0) , leaving n=2-1 = 1
		- bob cannot make a move since we already see above that n=1 is a losing state

	
```

## ü§îWhat Did I Struggle With?

```

```

## üí° Explanation of Solution

```

```

## ‚åõ Complexity Analysis

```

```

## üíª Implementation of Solution

```cpp

```