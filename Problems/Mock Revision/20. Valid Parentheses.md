## ğŸ“ Problem Details

- **Title:** `20. Valid Parentheses`
- **Link:** https://leetcode.com/problems/valid-parentheses/
- **Difficulty:** #Easy 
- **Tags/Categories:**  #Hashmap #Strings #Stack 

## ğŸ’­What Were My Initial Thoughts?

```
- the order of the parentheses matter
- a stack which only contains the opening parentheses will allow us to keep track of the process of opening and closing brackets
- use a hashmap to create a key value pair relationship between opening and closing brackets of the same kind
```

## ğŸ¤”What Did I Struggle With?

```
~ did good on this question
- made a small blunder with the complexity analysis, saying that the space complexity was only O(log n) since we were only storing the opening brackets
```

## ğŸ’¡ Explanation of Solution

```
- predefine a hashmap of characters where the key is the closing bracket and the value is the opening bracket
- initialize a stack for the open brackets

- iterate through the input string
- check if the char exists in the hashmap (checking if its an closing bracket)
	- if it does, check if the top of the stack is the mapped closing brakcet
	- return false if it doesnt, if it does pop the item from the stack and continue
- if it doesnt, its an opening bracket so push it into the stack
```

## âŒ› Complexity Analysis

```
Time Complexity: O(n) for every character in the input string s
Space Complexity: O(n) in the case where all opening brackets are stored in the stack 
```

## ğŸ’» Implementation of Solution

```cpp
class Solution {
public:
Â  Â  bool isValid(string s) {
Â  Â  Â  Â  stack<char> open;
Â  Â  Â  Â  
Â  Â  Â  Â  unordered_map<char, char> brackets = {
Â  Â  Â  Â  Â  Â  {')','('},
Â  Â  Â  Â  Â  Â  {'}','{'},
Â  Â  Â  Â  Â  Â  {']','['}
Â  Â  Â  Â  };

Â  Â  Â  Â  for(const auto& c : s) {
Â  Â  Â  Â  Â  Â  if(brackets.find(c) != brackets.end()) {
Â  Â  Â  Â  Â  Â  Â  Â  if(open.empty()) return false;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if(open.top() != brackets[c]) return false;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  open.pop();
Â  Â  Â  Â  Â  Â  } else Â {
Â  Â  Â  Â  Â  Â  Â  Â  open.push(c);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return open.empty();
Â  Â  }
};
```