## ğŸ“ Problem Details

- **Title:** `199. Binary Tree Right Side View`
- **Link:** https://leetcode.com/problems/binary-tree-right-side-view/
- **Difficulty:** #Medium 
- **Tags/Categories:** #BFS #DFS 

## ğŸ’­What Were My Initial Thoughts?

```
- we can do either a DFS or BFS 
- go as far down the right subtree as possible, keeping track of the level we are on
- check if the level and size of the results array are equal, if they are then it means we havent inserted a right side node into our array yet
- if they arent equal, ignore the node and keep traversing
```

## ğŸ¤”What Did I Struggle With?

```
- a 3 is not reflective of how i did in this question
- i pretty much nailed the question, but i was given a low 'coding mark' since i had to go straight from example/algo explanation to code due to time constraints
- dfs is such a simple algo that pseudocode was almost not necessary but was omission of pseudocode was the reason i failed
```

## ğŸ’¡ Explanation of Solution

```
same as intuition
```

## âŒ› Complexity Analysis

```
Time Complexity: O(n)
Space Complexity: O(n) since our results vector could be right skewed and we could return a total of n elements
```

## ğŸ’» Implementation of Solution (DFS)

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        dfs(root, 0, result);
        return result;
    }

private:
    void dfs(TreeNode* node, int depth, vector<int>& result) {
        if (!node) return;

        // If this is the first time visiting this depth, add the node's value
        if (depth == result.size()) {
            result.push_back(node->val);
        }

        // Recurse to the right first, then the left
        dfs(node->right, depth + 1, result);
        dfs(node->left, depth + 1, result);
    }
};
```


## ğŸ’» Implementation of Solution (BFS)

```cpp
class Solution {

public:
Â  Â  vector<int> rightSideView(TreeNode* root) {
Â  Â  Â  Â  vector<int> result;
Â  Â  Â  Â  if(!root) return result;
  
Â  Â  Â  Â  queue<TreeNode*> q;
Â  Â  Â  Â  q.push(root);

Â  Â  Â  Â  while(!q.empty()) {
Â  Â  Â  Â  Â  Â  int levelSize = q.size();

Â  Â  Â  Â  Â  Â  for(int i=0; i < levelSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  TreeNode* currentNode = q.front();
Â  Â  Â  Â  Â  Â  Â  Â  q.pop();
  
Â  Â  Â  Â  Â  Â  Â  Â  //if its the last node in the current level, add it to result
Â  Â  Â  Â  Â  Â  Â  Â  if(i == levelSize -1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result.push_back(currentNode->val);
Â  Â  Â  Â  Â  Â  Â  Â  }
  
Â  Â  Â  Â  Â  Â  Â  Â  if(currentNode->left) q.push(currentNode->left);
Â  Â  Â  Â  Â  Â  Â  Â  if(currentNode->right) q.push(currentNode->right);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return result;
Â  Â  }
};
```