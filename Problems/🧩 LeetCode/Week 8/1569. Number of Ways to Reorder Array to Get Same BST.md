## üìù Problem Details

- **Title:** `1569. Number of Ways to Reorder Array to Get Same BST`
- **Link:** https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/
- **Difficulty:** #Hard 
- **Tags/Categories:** #Dynamic-Programming #DFS #Divide-and-Conquer #BST

## üí≠What Were My Initial Thoughts?

```
- elements are unique and between 1-1000
- tree is not self-balancing, therefore we dont need to worry about rebalancing in the event of insertion
- return the number of combinations as modulo 10^9+7

- the root of the tree always has to be the first element in the array, as it will determine the correctness of the left and right subtrees
	- need some kind of subproblem after the base case, which would be the insertion of the root node (starting element)
```

## ü§îWhat Did I Struggle With?

```
prerequisite knowledge needed to solve this problem:
- binomial coefficient for calculating combinatorics 

also couldnt figure out the recurrence relation for this problem 
```

## üí° Explanation of Solution

```
1. Root Determination: the first element of the array always becomes the root of the BST, as insertion in BST starts with the first element

2. Subproblems:
	- divide the array into two parts: 
	- elements less than the root (left subtree)
	- elements greater than root (right subtree)
	- for each subtree, recursively determine the number of ways to reorder it to produce the same subtree structure

3. Combination Formula:
	- the number of ways to interleave left and right subtree elements while maintaining their relative order is determined by combinatorics 
	- if n elements are divided into 1 (left) and r (right), the formula for choosing positions is:
	- binomial coefficient formula 

4. Modulo Arithmetic:
	- Since the result needs to be modulo 10^9+7, use modular arithmetic in *all* calculations to avoid overflow
```

## ‚åõ Complexity Analysis

```
Time Complexity: O()
```

## üíª Implementation of Solution

```cpp

```