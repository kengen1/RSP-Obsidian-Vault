## üìç Problem Details

- **Title:** `518. Coin Change II`
- **Link:** [https://leetcode.com/problems/coin-change-ii/](https://leetcode.com/problems/coin-change-ii/)
- **Difficulty:** #Medium
- **Tags/Categories:** #Dynamic-Programming

## üóûÔ∏è What Were My Initial Thoughts?

```
When approaching this problem, my initial idea was to use a dynamic programming (DP) approach to count the number of ways to make up the given `amount` using the available `coins`. Since this problem allows for an unlimited number of coins, I thought of solving it using a bottom-up approach.

I planned to iterate through the coins and, for each coin, update the number of ways to make every amount from the coin's value up to the target amount. This would ensure that we correctly consider all combinations of coins for each amount.
```

## ü§î What Did I Struggle With?

```
Initially, I struggled with implementing the bottom-up DP approach because my solution was failing for larger test cases due to integer overflow when using the standard `int` type for the DP array. C++ couldn‚Äôt handle the large values generated during the summation in certain scenarios where the number of ways to form an amount was large.

To address this, I switched to using `uint64_t` for the DP array, which allowed me to avoid overflow issues.
```

## üí° Explanation of Solution

```
The problem is solved using dynamic programming. The key idea is to **iteratively** calculate the number of ways to make up every amount from `0` to `amount` using the available coins. The recurrence relation used is:

    dp[x] = dp[x] + dp[x - coin[i]]

### Explanation of the Recurrence Relation:
- `dp[x]` represents the number of ways to form amount `x` using the given coins.
- For each coin `coin[i]`:
  - **Include coin[i]**: This adds the number of ways to form amount `x - coin[i]` (since we can reuse coins).
  - **Skip coin[i]**: This keeps the number of ways to form amount `x` without using this coin.

By iterating through each coin and updating the DP array for every target amount, we ensure that all combinations of coins are considered.

### Base Case:
- `dp[0] = 1`: There is exactly one way to make the amount `0` ‚Äî by using no coins.

### Steps:
1. Initialize a DP array of size `amount + 1` with all elements set to `0`.
2. Set `dp[0] = 1` to handle the base case.
3. For each coin, update the DP array for all amounts from the coin‚Äôs value up to `amount`.
4. Return `dp[amount]` as the final result, which represents the number of ways to make the target amount.
```

## ‚åõ Complexity Analysis

```
### Time Complexity:
- **O(n * amount)**: We iterate through each of the `n` coins, and for each coin, we update the DP array for all amounts from the coin‚Äôs value to `amount`.

### Space Complexity:
- **O(amount)**: The DP array stores the number of ways to make each amount up to `amount`.

### Note on Optimization:
The space complexity is reduced to `O(amount)` because we use a 1D DP array instead of a 2D DP table.
```

## üíª Implementation of Solution

```cpp
/*
Recurrence Relation Explanation:

for each coin coin[i], to make amount x:

- Include coin[i]: Add the number of ways to make x - coin[i] (since we can reuse coins).
- Skip coin[i]: Use the number of ways to make x without this coin.

Thus, the recurrence relation is:

    dp[x] = dp[x] + dp[x - coin[i]]

Where:
    dp[x] is the number of ways to make amount x.
    dp[0] = 1 (1 way to make amount 0: use no coins).

We update dp[x] for each coin iteratively to count the number of ways to form the amount.
*/

class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();

        // Use a vector of uint64_t to avoid overflow for large test cases.
        vector<uint64_t> dp(amount + 1, 0);

        // Base case: There's 1 way to make the amount 0 (use no coins).
        dp[0] = 1;

        // Iterate through coins from the last to the first.
        for (int coin = n - 1; coin >= 0; coin--) {
            // For each coin, update the dp array for all target amounts.
            for (int target = coins[coin]; target <= amount; target++) {
                dp[target] += dp[target - coins[coin]];
            }
        }

        // The answer is the number of ways to make the amount.
        return dp[amount];
    }
};
```