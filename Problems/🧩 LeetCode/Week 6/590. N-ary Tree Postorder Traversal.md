## ðŸ“ Problem Details

- **Title:** `590. N-ary Tree Postorder Traversal`
- **Link:** https://leetcode.com/problems/n-ary-tree-postorder-traversal/
- **Difficulty:** #Easy 
- **Tags/Categories:**  #DFS #N-ary-Tree #Postorder 

## ðŸ’­What Were My Initial Thoughts?

```
- the problem lies with it being an n-ary tree which makes the traversal order a little more complicated
- binary tree traversal: left->right->current node
- n-ary tree traversal: each child from left to right-> current node
```

## ðŸ¤”What Did I Struggle With?

```
~
```

## ðŸ’¡ Explanation of Solution

```
- recursive solution
- init an empty result vector
- for each child in the roots children
	- construct a new vector that is the result of recursive call with the child as the param
	- insert that childResult into our result vector
- push the value of the current node into the result vector
- return the result
```

## âŒ› Complexity Analysis

```
Time Complexity: O(n) where N nodes are traversed once
Space Complexity: O(n) due to the recursion call stack
```

## ðŸ’» Implementation of Solution

```cpp
class Solution {

public:
Â  Â  vector<int> postorder(Node* root) {
Â  Â  Â  Â  if(root == nullptr) return {};
Â  Â  Â  Â  vector<int> result;

Â  Â  Â  Â  for (auto& child : root->children) {
Â  Â  Â  Â  Â  Â  vector<int> childResult = postorder(child);
Â  Â  Â  Â  Â  Â  result.insert(result.end(), childResult.begin(), childResult.end());
Â  Â  Â  Â  }

Â  Â  Â  Â  result.push_back(root->val); Â  Â // process the current nodes value
Â  Â  Â  Â  return result;
Â  Â  }
};
```