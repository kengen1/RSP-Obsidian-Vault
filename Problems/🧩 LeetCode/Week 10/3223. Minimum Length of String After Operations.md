## ðŸ“ Problem Details

- **Title:** `3223. Minimum Length of String After Operations`
- **Link:** https://leetcode.com/problems/minimum-length-of-string-after-operations/
- **Difficulty:** #Medium 
- **Tags/Categories:** `{{tags/categories}}`

## ðŸ’­What Were My Initial Thoughts?

```
- need at least 3 elements relating to a particular value in order to conduct a removal operation
- could create a hashmap, where the key is the char and the value is a list of indices where the chars are located 
```

## ðŸ¤”What Did I Struggle With?

```
~
```

## ðŸ’¡ Explanation of Solution

```
Observation:
- if a character appears odd times --> 1 character remains
- if a character appears even times --> 2 characcters remain
- instead of tracking indices explicitly , we can just count occurences of each character 
- based on the above observation, we only need to process each character once 

----------------------------------------------------------------------------------

- **Create a frequency hashmap** to count occurrences of each character.
- **For each character**, determine how many will remain after applying the removal rule:
    - If `freq % 2 == 1`, keep `1` character.
    - If `freq % 2 == 0`, keep `2` characters.
- **Sum up the remaining counts** to get the final string length.
```

## âŒ› Complexity Analysis

```
Time Complexity: O(n)

Space Complexity: O(n)
```

## ðŸ’» Implementation of Solution

```cpp
class Solution {
public:
Â  Â  int minimumLength(string s) {
Â  Â  Â  Â  unordered_map<char,int> map;
Â  Â  Â  Â  int res = 0;

Â  Â  Â  Â  for(char c : s) {
Â  Â  Â  Â  Â  Â  map[c]++;
Â  Â  Â  Â  }

Â  Â  Â  Â  for(auto it = map.begin(); it != map.end(); it++) {
Â  Â  Â  Â  Â  Â  if(it->second % 2 == 1) res++;
Â  Â  Â  Â  Â  Â  else res += 2;
Â  Â  Â  Â  }
Â  Â  Â  Â  return res;
Â  Â  }
};
```