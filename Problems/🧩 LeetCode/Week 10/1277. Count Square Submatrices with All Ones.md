## üìù Problem Details

- **Title:** `1277. Count Square Submatrices with All Ones`
- **Link:** https://leetcode.com/problems/count-square-submatrices-with-all-ones/
- **Difficulty:** #Medium 
- **Tags/Categories:** #Dynamic-Programming #Arrays #Matrix 

## üí≠What Were My Initial Thoughts?

```
Na√Øve approach:
- Count all individual 1s.
- Count all 2√ó2 matrices.
- Count all 3√ó3 matrices.
- Continue until reaching the largest possible square.

Issues with this approach:
- Repeatedly scanning the matrix for different square sizes is inefficient.
- This leads to a worst-case time complexity of O(n¬≥) in brute force.
- There must be a way to break this into smaller subproblems and build up the solution.

```

## ü§îWhat Did I Struggle With?

```
- Initially, I was unsure whether to approach this problem top-down (starting from the largest possible square) or bottom-up.
- Understanding how to transition from smaller subproblems to larger squares using DP.
- Determining how to store and use previous results efficiently.
- Finding a space-optimized way to store the DP values instead of using a full 2D matrix.
```

## üí° Explanation of Solution

```
Step 1: Define the DP State
- Let `dp[i][j]` represent the size of the largest square that ends at (i, j)
- The final answer will be the sum of all `dp[i][j]` values.


Step 2: Base Case
- If `matrix[i][j] == 1` and it's in the **first row (i == 0) or first column (j == 0)**, then `dp[i][j] = 1` (it can only form a 1√ó1 square).
- Otherwise, use the DP formula:
	dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
	

Step 3: Transition
- If a `1` is found at `(i, j)`, check its top, left, and top-left diagonal neighbors:
  - If all three are part of a square, extend it.
  - Otherwise, `dp[i][j]` can only be `1`.


Step 4: Optimizing Space
- Instead of using a full `dp` matrix (`O(m √ó n)` space), we:
  - Maintain **only one row** (`O(n) space`).
  - Keep a `prev` variable to store `dp[i-1][j-1]` (top-left diagonal).


Step 5: Summing the Squares
- The sum of all `dp[i][j]` values gives the final count of square submatrices.

```

## ‚åõ Complexity Analysis

```
Time Complexity: O(m * n)
	- each cell is visited once, making it linear with respect to the matrix size 

Space Complexity: O(n)
	- instead of storing a full 2D table, we only store 
```

## üíª Implementation of Solution

```cpp

```