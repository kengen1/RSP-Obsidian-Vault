## üìù Problem Details

- **Title:** `322. Coin Change`
- **Link:** https://leetcode.com/problems/coin-change
- **Difficulty:** #Medium 
- **Tags/Categories:** #Dynamic-Programming 

## üí≠What Were My Initial Thoughts?

```
1. initial approach
	- a greedy approach first comes to mind, where we greedily select the largest element in the list that is within the range of the current accumulated value and the target value
	- this will not work as greedily choosing the largest elements can create impossible scenarios where there are possibilities with difference combinations 

2. intuitive approach
we can break the problem down into a decision tree
where we start from 11, and try and progressively reduce the value to 0
each 'node' in the tree has n possibility (where n is the different coins in the array)
subtract each coin from the current value and continue down the tree until we reach zero
the number of levels traversed (or recursed) is the number of coins used 
we keep track of the minimum levels traversed, pruning branches each time they exceed our current min number of coins 
if decision line results in the value being less than zero, prune it also and return INT_MAX (to say its invalid)

- this is intuitively correct, but is computationally complex as we are essentially computing every combination of coins and returning the minimum number of coins used to get our value amount
- even with pruning it probably isnt efficient enough
```

## ü§îWhat Did I Struggle With?

```
~
```

## üí° Explanation of Solution

```
Top-Down Dynamic Programming with Memoization (caching)
- continuing on from the intuitive approach, if we were to visualise the decision tree, you can see that we are recalculating the minimum number of coins to achieve value x across multiple areas of the problem
- we can use a dp array to store (cache) the minimum number of coins needed to get the values 0 - amount
- this will avoid / prevent repeated computation since we have identified that by doing this decision tree approach, we can see that the subproblems are recurring across different branches 

Base Case: zero coins are needed to make amount 0

Pruning: if the amount is < 0 , return -1
- if dp[amount] is already computed (doesnt have a value of INT_MAX), return it directly to avoid unecessary recursion


```

## ‚åõ Complexity Analysis

```

```

## üíª Implementation of Solution

```cpp
class Solution {
public:

    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0; // base case : 0 coins to make amount 0

        auto helper = [&](int amt, auto&& helper_ref) -> int { 
            if(amt < 0) return -1; // invalid amount
            if(dp[amt] != INT_MAX) return dp[amt]; // use cached result

            int minCoins = INT_MAX;
            for(int coin : coins) {
                int res = helper_ref(amt - coin, helper_ref); // recursive call
                if(res != -1) minCoins = min(minCoins, res + 1);
            }

            dp[amt] = (minCoins == INT_MAX) ? -1 : minCoins;
            return dp[amt];
        };

        // call the lambda function with the initial amount
        return helper(amount, helper);
    }
};
```