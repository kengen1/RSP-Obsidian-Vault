#Leetcode 
## ğŸ“ Problem Details

- **Title:** `33. Search in Rotated Sorted Array`
- **Link:**  https://leetcode.com/problems/search-in-rotated-sorted-array/
- **Difficulty:** #Medium 
- **Tags/Categories:** #Binary-Search

## ğŸ’­What Were My Initial Thoughts?

```
- brute force would be to just iterate through the array and check if the current value equals our target
	- this will not fit the time complexity requirement of O(log n) however
- if the array was sorted, a binary search would be a simple solution
- maybe we can still employ binary search since the array is partially sorted
- the array also has two primary components based on where the rotation finishes
```

## ğŸ¤”What Did I Struggle With?

```
figuring out how to action the use of binary search in this case
```

## ğŸ’¡ Explanation of Solution

```
1. use binary search to find the target
2. identify the sorted half: for each iteration determine whether the left or right half of the array is sorted by comparing nums[left] and nums[mid]
3. search in the sorted half
4. continue 2 and 3 until the target index is found or return 01
```

## âŒ› Complexity Analysis

```
Time Complexity: O(log n) based on the requireemnts of the problem

Space Compelxity: O(1)
```

## ğŸ’» Implementation of Solution

```cpp
class Solution {

public:
Â  Â  int search(vector<int>& nums, int target) {
Â  Â  Â  Â  int left = 0;
Â  Â  Â  Â  int right = nums.size()-1;

Â  Â  Â  Â  while(left <= right) {
Â  Â  Â  Â  Â  Â  int mid = left + (right - left) /2;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if(nums[mid] == target) return mid;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if(nums[left] <= nums[mid]) {
Â  Â  Â  Â  Â  Â  Â  Â  if(nums[left] <= target && nums[mid] >= target) right = mid -1;
Â  Â  Â  Â  Â  Â  Â  Â  else left = mid + 1;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â  Â  if(nums[right] >= target && nums[mid] <= target) left = mid + 1;
Â  Â  Â  Â  Â  Â  Â  Â  else right = mid -1;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return -1;
Â  Â  }
};
```